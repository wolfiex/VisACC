<!DOCTYPE html>
<meta charset="utf-8">
<style>
@import url(./style.css);
#graphdiv {
  position: absolute;
  left: 0px;
}



.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}



</style>

<script src="three.js"></script>
<script src="./TrackballControls.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src = './graph_classes.js'></script>
<script src="./functions.js"></script>
<script src="./stats.js"></script>
<link src='./fonts'  rel='stylesheet' type='text/css'>
<!-- href='https://fonts.googleapis.com/css?family=Open+Sans|Lato|Vidaloka|Fira+Sans|Fredericka+the+Great|Ubuntu'
-->

<body>
  <svg>
  </svg>

  <div id="graphdiv">
  </div>

</body>


<script>
/// main action script
const electron = require('electron');
const fs = require('fs');
const NetCDFReader = require('netcdfjs');
var ipc = electron.ipcRenderer;
ipc.on('toggle-prefs', (event,arg)=> {console.log(event,arg)});


//parameters - netcdf
var data = fs.readFileSync('volcano.nc');
var reader = new NetCDFReader(data); // read the header
// get data dimentions
reader.dimensions.forEach(function(d){dims[d.name] = d.size},dims={});

class nc2D {
  constructor(name, width, arr_type) { //Float32Array
    this.width = dims[width];
    this.arr_type = arr_type
    this.data = new arr_type(reader.getDataVariable(name));
  }
};

nc2D.prototype.row = function (index) {
   start = index*this.width;
   return new this.arr_type(this.data.slice(start,start+this.width))
}



const concentration = new nc2D('concentration','specs',Float32Array);
const flux = new nc2D('edge-length','fluxes',Float32Array);
const dict = JSON.parse(reader.getDataVariable('nodes').join(''));
const combine = JSON.parse(reader.getDataVariable('combinations').join(''));
const tar = reader.getDataVariable('target');
const src = reader.getDataVariable('source');
//time array
//location array
//primary spec list

// creates reverse dictionary rdict below
Object.keys(dict).forEach(function(d){var i = dict[d];rdict[i]=d;}, rdict={}, nodes=[]);

window.nodes =[];for (i = 0; i < combine.length; i++) { window.nodes.push({"names":rdict[i],"id":i,"x":2*(0.5-Math.random()),
"y":2*(0.5-Math.random()),"z":0.5-Math.random()}) };
//all_links =[];for (i = 0; i < src.length; i++) { all_links.push({"source":src[i],"target":tar[i],"index":i}) };


var print = (d) => console.log(d);



timestep=1;

const edge_len = flux.row(timestep)
window.concs = concentration.row(timestep)

//all_links.filter(function(d){if(isFinite(window.edge_len[d.index])){d.l = window.edge_len[d.index] ; links.push(d)}},links=[]);


// edge_length.map((d)=>1000*d);

// map for combination

window.pw=window.innerWidth/2.;
window.ph=window.innerHeight/2.;
var svg = d3.select("svg");
svg.style('width', window.innerWidth);
svg.style('height', window.innerHeight);
svg.style("transform", "translate("+window.innerWidth/2.+","+window.innerHeight/2.+")")

var color = d3.scaleOrdinal(d3.schemeCategory20);






combine.forEach(function(f){

  var prod = f[0];
  var loss = f[1];

  var flx = 0;

  for (i = 0; i < prod.length; i++) {var j = edge_len[prod[i]]; if (isFinite(j)){ flx -= j}};
  for (i = 0; i < loss.length; i++) {var j = edge_len[loss[i]]; if (isFinite(j)){ flx -= j}};


  sign.push(Math.sign(flx));
  flx = Math.log10(Math.abs(flx));
  mylink.push(flx);
  if (isFinite(flx)) dummy.push(flx);

},mylink=[],dummy=[],sign=[]);

//normalize
var min =  d3.min(dummy)
var max =  d3.max(dummy)-min
mylink = mylink.map((d)=>(d-min+1e-6)/max)


// create links object
window.graphlinks =[]
for (i = 0; i < combine.length; i++) {

if (sign[i] !== 0) {
  console.log(mylink[i],i)
  graphlinks.push({"source":src[i],"target":tar[i], "kkv":Number(mylink[i].toFixed(3)), "kkd":sign[i]}) };

}



</script>

<script>



this.csvdata=[]
this.graph=[]
//default params
window.onresize = function(event) {location.reload()};
window.scrollTo(window.innerWidth/2, window.innerHeight/2);
window.linkleneq=  'dv'

var constant = 0.5,
scaled=1.1, // if scale >1 multiply css by that number too
width = window.innerWidth*scaled,
height = window.innerHeight*scaled,
node_sizes=[],
textcolour='white',
primary = ["BENZENE", "C2H2", "C2H6", "TOLUENE", "IC4H10", "NC4H10", "C3H8", "CH4", "APINENE", "C5H8", "C3H6", "CO"],
plus_ns=10;


//d3.select('body').style('background-color', '#222'); // bg colour


d3.csv("./src/fullmcmspecs.csv", function(error, csv) {this.csvdata=csv});     //get list of all species etc


window.color = d3.interpolate("#F6089E", "#3864EB");    //https://github.com/d3/d3-scale
window.color1 = d3.interpolate('#222','blue') ///'blue',"#F6089E");


</script>

<script>

//stats window
(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='stats.js';document.head.appendChild(script);})()
const cp = require('child_process');


var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera(450, width / height, 0.1, 1000);
//var camera = new THREE.OrthographicCamera( -200, 200, -200, 200, 1, 1000 );
camera.up = new THREE.Vector3( 0, 0, 1 );

camera.position.x = -0.1;
camera.position.y = -0.1;
camera.position.z = +200;
camera.lookAt(scene.position);

//Math.tan(45* Math.PI/180)*-50;

var renderer = new THREE.WebGLRenderer({
  precision: 'highp',
  antialias: true,
  //alpha: true  ,
  preserveDrawingBuffer: true});
  renderer.setSize(width, height);
  //renderer.shadowMapEnabled = true;
  //renderer.shadowMapSoft = true;



  /*
  var cube = new THREE.BoxHelper() ;
  cube.material.color='black';
  cube.scale.set( 10, 10, 10);
  cube.material.fragmentShader='black'

  scene.add( cube );
  */



  var controls = new THREE.TrackballControls(camera);

  document.getElementById('graphdiv').appendChild(renderer.domElement);

  //scene.add(new THREE.AmbientLight(0x111111));

  var light = new THREE.DirectionalLight(0xffffff, 1);
  light.shadowCameraVisible = true;
  light.position.set(-0,0,100);
  scene.add(light);

  var light = new THREE.DirectionalLight(0xffffff, 1);
  light.shadowCameraVisible = true;
  light.position.set(-0,0,-100);
  scene.add(light);


  var ambientLight = new THREE.AmbientLight(0x090909);
  scene.add(ambientLight);




  function constrain(v, min, max){
    if( v < min )
    v = min;
    else
    if( v > max )
    v = max;
    return v;
  }

    function createLinePoints(startPoint, endPoint){
      var numPoints = 30;
      var returnPoints = [];
      for(i=0; i <= numPoints; i ++){
        var thisPoint = startPoint.clone().lerp(endPoint, i/numPoints);
        returnPoints.push(thisPoint);
      }
      return returnPoints;
    }




  var numParticles = 400;
  var material = new THREE.LineBasicMaterial({color: 0x0000ff });
  //First create the line that we want to animate the particles along


  var startPoint = new THREE.Vector3(-80, 0, -800)
  var endPoint = new THREE.Vector3(800, 0, 800)




  render();

  function render() {
    controls.update();
    requestAnimationFrame(render);
      renderer.render(scene, camera);
      if (window.help) window.plotobject.river();
    //UpdateParticles();
  }




  </script>

  <script src ="./forcegraph.js"></script>
